import time
from pathlib import Path
from typing import Optional, Dict, Any

from course_components.anthropic_client import AnthropicClient


class ChapterGenerator:
    """
    Generate structured course chapter markdown files from transcripts using Claude.
    """
    
    def __init__(self, api_key: Optional[str] = None):
        """
        Initialize the chapter generator.
        
        Args:
            api_key: Anthropic API key. If None, will read from environment variable.
        """
        self.client = AnthropicClient(api_key=api_key)
        self.system_prompt = self._get_system_prompt()
    
    def _get_system_prompt(self) -> str:
        """Get the system prompt for chapter generation."""
        return """You are an expert course content creator. Your task is to transform video transcripts into well-structured course chapters in markdown format.

REQUIREMENTS:
1. Use ONLY ### (h3) and #### (h4) headings - NO ## (h2) or # (h1) headings
2. Create logical sections with ### headings for main topics
3. Use #### headings for subtopics within sections
4. Format content into clear, readable paragraphs
5. Maintain the educational value and flow of the original content
6. Remove filler words and conversational artifacts while preserving meaning
7. Structure the content for learning, with clear topic progression

OUTPUT FORMAT:
- Start with a ### heading for the main chapter title
- Use ### for major sections/topics
- Use #### for subsections/subtopics  
- Write in clear, professional paragraphs
- Maintain logical flow between sections
- Keep technical accuracy from the original transcript

EXAMPLE STRUCTURE:
### Chapter Title: Core Concepts

#### Introduction
Clear paragraph explaining the main topic...

#### Key Concept 1
Detailed explanation with examples...

#### Key Concept 2
Further explanation building on previous concepts...

### Advanced Topics

#### Advanced Concept 1
More complex material...

Transform the transcript while maintaining educational value and creating a professional course chapter."""
    
    def generate_chapter(
        self, 
        transcript_content: str, 
        source_info: Optional[Dict[str, Any]] = None,
        chapter_title: Optional[str] = None
    ) -> str:
        """
        Generate a chapter markdown from transcript content.
        
        Args:
            transcript_content: The transcript text to convert
            source_info: Optional metadata about the source (video_id, url, etc.)
            chapter_title: Optional custom title for the chapter
            
        Returns:
            Generated chapter markdown content
        """
        # Build the user prompt
        prompt = f"""Transform this video transcript into a well-structured course chapter:

TRANSCRIPT:
{transcript_content}

INSTRUCTIONS:
- Create a comprehensive chapter with clear structure
- Use ### and #### headings only
- Focus on educational content and learning objectives
- Remove conversational filler while preserving all important information
- Organize content logically for learning progression"""
        
        if chapter_title:
            prompt += f"\n- Use '{chapter_title}' as the main chapter title"
        
        # Generate chapter content
        chapter_content = self.client.generate_text(
            prompt=prompt,
            system_prompt=self.system_prompt,
            max_tokens=4000,
            temperature=0.1
        )
        
        # Add metadata header if source info is provided
        if source_info:
            metadata = self._create_metadata_header(source_info)
            chapter_content = metadata + "\n" + chapter_content
        
        return chapter_content
    
    def _create_metadata_header(self, source_info: Dict[str, Any]) -> str:
        """Create a metadata header for the chapter."""
        header_lines = ["<!-- Chapter Metadata -->"]
        
        if 'video_id' in source_info:
            header_lines.append(f"<!-- Source Video ID: {source_info['video_id']} -->")
        
        if 'url' in source_info:
            header_lines.append(f"<!-- Source URL: {source_info['url']} -->")
        
        if 'transcript_file' in source_info:
            header_lines.append(f"<!-- Source Transcript: {source_info['transcript_file']} -->")
        
        header_lines.append(f"<!-- Generated: {time.strftime('%Y-%m-%d %H:%M:%S')} -->")
        header_lines.append("<!-- Generated by Course Ally Chapter Generator -->")
        
        return "\n".join(header_lines)
    
    def generate_chapter_from_file(
        self, 
        transcript_file: Path, 
        output_file: Optional[Path] = None,
        chapter_title: Optional[str] = None
    ) -> str:
        """
        Generate chapter from a transcript file.
        
        Args:
            transcript_file: Path to the transcript file
            output_file: Optional path to save the generated chapter
            chapter_title: Optional custom title for the chapter
            
        Returns:
            Generated chapter content
        """
        # Read transcript file
        if not transcript_file.exists():
            raise FileNotFoundError(f"Transcript file not found: {transcript_file}")
        
        transcript_content = transcript_file.read_text(encoding='utf-8')
        
        # Extract metadata from transcript header if present
        source_info = self._extract_source_info(transcript_content, transcript_file)
        
        # Remove metadata header from content for processing
        clean_content = self._clean_transcript_content(transcript_content)
        
        # Generate chapter
        chapter_content = self.generate_chapter(
            transcript_content=clean_content,
            source_info=source_info,
            chapter_title=chapter_title
        )
        
        # Save to output file if specified
        if output_file:
            output_file.parent.mkdir(parents=True, exist_ok=True)
            output_file.write_text(chapter_content, encoding='utf-8')
        
        return chapter_content
    
    def _extract_source_info(self, content: str, file_path: Path) -> Dict[str, Any]:
        """Extract source information from transcript content."""
        source_info = {'transcript_file': file_path.name}
        
        lines = content.split('\n')
        for line in lines[:10]:  # Check first 10 lines for metadata
            if 'Video ID:' in line:
                source_info['video_id'] = line.split('Video ID:')[1].strip()
            elif 'URL:' in line and 'youtube.com' in line:
                source_info['url'] = line.split('URL:')[1].strip()
        
        return source_info
    
    def _clean_transcript_content(self, content: str) -> str:
        """Remove metadata header from transcript content."""
        lines = content.split('\n')
        
        # Find the end of metadata section (usually marked by === line)
        content_start = 0
        for i, line in enumerate(lines):
            if '=' * 10 in line:  # Look for separator line
                content_start = i + 1
                break
        
        # Join remaining lines
        return '\n'.join(lines[content_start:]).strip()
    
    def get_client_info(self) -> Dict[str, Any]:
        """Get information about the underlying API client."""
        return self.client.get_usage_info()